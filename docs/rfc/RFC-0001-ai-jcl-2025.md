# **RFC — AI Job Control Language (JCL), 2025 Edition™**

**Author:** Emily Yoshida  
**Organization:** Self (NexixAI)  
**Status:** Draft  
**Last Updated:** 2025-01-27

* * *

## **1. Abstract**

AI Job Control Language (JCL), 2025 Edition™ defines a disciplined, deterministic way to run AI-assisted implementation work without losing architectural control. It is not a programming language. It is not a framework. It is a *control language*—written by humans, executed by AI—that governs how changes are made, verified, and proven.

The goal of AI JCL is simple: prevent AI from confidently doing the wrong thing, claiming success without evidence, or quietly introducing long-term system debt under the guise of speed.

The structure and philosophy are intentional. AI JCL borrows directly from concepts I first encountered early in my career while writing COBOL Job Control Language: explicit execution boundaries, declared intent before execution, strict separation between control and work, and an expectation that every job produces verifiable output—or fails loudly and immediately. Back then, JCL existed because production systems were too expensive, too stateful, and too fragile to tolerate ambiguity or “best guesses.” The same is now true of AI-driven engineering.

If this feels familiar to anyone who has operated large, long-lived production systems, that’s not an accident. AI JCL exists for the same reason classic JCL did: when systems become powerful enough, speed without control stops being an advantage and starts becoming a liability.

* * *

## **2. Motivation**

Modern AI coding systems are optimized for plausibility and velocity. They are very good at producing something that *looks* right. Unfortunately, production systems don’t fail because things look wrong—they fail because something subtle was misunderstood, silently skipped, or “helpfully” worked around.

After repeated exposure to AI-generated changes that claimed correctness without proof, relied on fallback behavior, or preserved compatibility paths that should have been deleted, it became clear that what was missing was not intelligence but discipline.

AI JCL exists to reintroduce that discipline. It treats AI execution the same way earlier generations treated batch jobs on critical systems: explicitly defined inputs, explicit steps, explicit failure conditions, and observable outputs. No magic. No guessing. No trust without verification.

* * *

## **3. Design Philosophy**

AI JCL is intentionally conservative. It values correctness over speed and clarity over convenience. Creativity is not forbidden, but it is tightly constrained. If a step is not written down, it must not happen. If a file is missing, execution stops. If proof is required, it must be shown, not summarized.

There is one canonical source of truth for each artifact class. Pointer documents, compatibility stubs, and “temporary” fallbacks are treated as architectural debt, not kindness. The system should either be correct or fail loudly.

Most importantly, AI JCL is designed to keep humans in control. Humans decide what is allowed to change and how success is measured. The AI’s job is to execute those instructions precisely and to prove that it did so.

* * *

## **4. What AI JCL Is—and What It Is Not**

AI JCL is a procedural execution contract. It is a way to tell an AI: *this is the job, this is the order, these are the constraints, and this is how you prove you did it.*

It is not a programming language, and it is not a prompt for ideation. It is deliberately hostile to “best effort” behavior. If something is ambiguous, execution should stop. If something cannot be proven, it should be treated as a failure.

* * *

## **5. Structure of an AI JCL Job**

Every AI JCL job starts by explicitly defining the role of the AI. The phrase “You are a deterministic AI implementor” is not decorative—it disables exploratory behavior and reframes the interaction as execution, not collaboration.

Next comes change classification. Before any work begins, the AI must acknowledge whether the change affects behavior, APIs, schemas, or data. These declarations are binding. If the AI later violates them, the job is invalid, regardless of intent.

Hard policies come next. These are non-negotiable constraints: no aliases, no fallbacks, no compatibility stubs, no undocumented files. If a hard policy conflicts with convenience, convenience loses.

Execution then proceeds step by step. Environment sanity checks come first. Canonical paths are defined explicitly. Mutations are performed only after the baseline is known. Verification is mandatory, not optional, and proof must be pasted verbatim.

Finally, commits and pull requests are handled explicitly. Branch provenance matters. Stale-base work is not acceptable. The AI does not get to “assume” it is on the right branch.

* * *

## **6. Proof and Verification**

One of the core failures of AI-assisted development is fake proof. Statements like “tests passed” or “no issues found” are meaningless unless backed by raw output.

AI JCL requires that verification commands—such as ripgrep scans, test runs, or configuration renders—be executed and pasted exactly as they appear in the terminal. If there is no output, that absence must itself be shown.

If an AI cannot produce raw output, it must not claim that a command was run. This rule exists specifically to eliminate hallucinated success.

* * *

## **7. Failure Semantics**

AI JCL is intentionally unforgiving. Missing canonical documents cause execution to stop. Broken links are failures, not warnings. Non-zero exit codes are failures. Fallback logic is forbidden unless explicitly allowed.

There is no “best effort” mode and no partial credit. This is by design. In complex systems, silent partial success is far more dangerous than loud failure.

* * *

## **8. Historical Parallels**

AI JCL borrows heavily—intentionally—from classic mainframe operational discipline. Batch jobs, explicit inputs, observable outputs, and hard failure modes are not outdated ideas; they are proven ones.

The fact that this structure feels familiar to anyone who has worked with COBOL JCL, ops runbooks, or early production systems is not nostalgia. It is pattern recognition.

The tools have changed. The need for control has not.

* * *

## **9. When to Use AI JCL**

AI JCL is not meant for quick experiments or throwaway scripts. It is meant for platform code, infrastructure, specifications, and systems where correctness compounds over time.

If a repository defines long-lived architecture, AI JCL should be the default. If breaking something would cost days instead of minutes, AI JCL is worth the overhead.

* * *

## **10. Future Directions**

AI JCL may eventually become machine-parseable. It may integrate directly with CI systems or produce signed execution transcripts. It may even support multi-AI quorum execution.

Those are implementation details. The core idea will remain the same: AI should execute with the same discipline we once demanded of systems that ran entire enterprises.

* * *

## **11. Closing Thoughts**

AI Job Control Language exists because speed without control is not progress—it is deferred failure.

This RFC formalizes something many experienced engineers already know instinctively: when execution becomes cheap, rigor becomes priceless.

* * *

## **12. Appendix — Templates, Execution Blocks, and Canonical Prompts**

This appendix contains **ready-to-use AI JCL templates**. These are not examples for inspiration; they are *operational artifacts*. You paste them, fill in the blanks, and run them. If you deviate, you should do so intentionally and visibly.

* * *

### **12.1 Canonical AI JCL Header (Required for All Jobs)**

Every AI JCL job MUST start with this header. No exceptions.

```
CODEX IMPLEMENTOR PROMPT

ROLE
You are a deterministic AI implementor.
You execute instructions exactly as written.
You do not infer intent.
You do not preserve compatibility unless explicitly instructed.
You do not claim actions without raw proof.

If any instruction conflicts, precedence is:
1) This prompt
2) NexixAI-AI-Implementor-Standard-v1.md
3) SPEC_AUTHORITY.md
```

If this header is missing, the job is considered informal and non-binding.

* * *

### **12.2 Change Classification Block (Mandatory)**

This block exists to prevent scope creep and silent refactors.

```
CHANGE CLASSIFICATION

Change Type: Hygiene / Documentation / Rename / Functional / Spec
Behavioral Change: YES / NO
API Contract Change: YES / NO
Schema Change: YES / NO
Data Migration Required: YES / NO
Risk Level: Low / Medium / High
Rollback Strategy: Revert commits
```

Once declared, these constraints are binding.

If the AI violates them, the job is invalid even if “tests pass.”

* * *

### **12.3 Hard Policy Block (Use Aggressively)**

Hard policy exists to remove ambiguity and eliminate “helpful” behavior.

```
HARD POLICY (NON-NEGOTIABLE)

• Do not preserve legacy aliases or compatibility paths.
• Do not introduce fallback logic.
• Do not create or retain pointer/stub files.
• Do not summarize command output.
• Do not claim commands were run unless raw output is pasted.
• If a required file is missing, STOP and report.
• If verification fails, STOP and report.
```

This block is especially important for hygiene and cleanup work.

* * *

### **12.4 Branch and PR Control Template**

Use this when amending an existing PR or enforcing branch hygiene.

```
BRANCH / PR RULES

• Work on existing PR: <PR_NUMBER>
• Do NOT create a new PR.
• All commits must land on the PR branch.
• Branch must be based on latest origin/main.

STEP 0 — IDENTIFY BRANCH (RAW)
gh pr view <PR_NUMBER> --json headRefName -q .headRefName
git checkout <HEAD_REF_NAME>

Paste raw output of:
git status
git branch --show-current
git log -1 --oneline
```

This block exists because stale-base work is one of the most common AI failure modes.

* * *

### **12.5 Repo Hygiene / Cleanup Job Template**

This is the template you just used. Yes, it *is* intense. That’s the point.

```
JOB: Repo Hygiene Cleanup (Zero Stubs, Canonical Only)

GOAL
Remove all pointer, stub, and duplicate artifacts.
Leave exactly one canonical path per artifact class.

STEP 1 — DEFINE CANON
Explicitly state which paths are canonical for:
• Plans
• Phases
• Tracks
• PRS
• Schemas
• Design

STEP 2 — DELETE NON-CANON
Delete all non-canonical files and directories.
Do NOT replace them with stubs or redirects.

STEP 3 — UPDATE REFERENCES
Update all references across the repo to point only to canonical paths.

STEP 4 — BROKEN LINK SCAN (RAW)
Run and paste raw output:
• scripts/docs/check-canonical-links.(sh|ps1)
• python3 scripts/docs/check-markdown-links.py

If any missing links exist: STOP.

STEP 5 — DIFF + PUSH (RAW)
git diff --stat
git push
```

* * *

### **12.6 Verification Proof Template (Anti–Fake Proof)**

This block should appear **verbatim** in PR descriptions.

```
VERIFICATION (RAW OUTPUT)

rg -n "<FORBIDDEN_PATTERN>" .
<PASTE OUTPUT>

go test -count=1 ./...
<PASTE OUTPUT>

docker compose -f <FILE> config
<PASTE OUTPUT>
```

If output is empty, paste the empty output.

Silence is still data.

* * *

### **12.7 Canonical “STOP Conditions” Block**

This is what keeps AI from plowing forward when it shouldn’t.

```
STOP CONDITIONS

STOP immediately if:
• Canonical files are missing
• Verification commands fail
• Forbidden tokens are found
• Instructions conflict or are ambiguous
• Required proof cannot be produced

When stopping:
• State exactly why
• Do not attempt partial fixes
• Do not continue execution
```

* * *

### **12.8 Minimal “Track Runner” Prompt Skeleton**

Use this for post-v1.02 execution tracks.

```
JOB: Execute Track <N>

ROLE
Deterministic AI implementor.

CANON
Track doc: docs/plan/<VERSION>/tracks/track-<N>-*.md

RULES
• No fallback to legacy paths
• No scope expansion
• No refactors beyond track scope

EXECUTION
Follow the track doc exactly.
If the doc is missing: STOP.

VERIFICATION
Paste raw outputs for all required commands.
```

* * *

### **12.9 One-Line Sanity Prompt (When You’re Tired)**

For late nights. This one saves you.

```
Before doing anything:
Confirm branch, canon paths, and STOP conditions.
If anything is unclear, STOP and ask.
```

* * *

### **12.10 Naming This What It Is**

**This ia an operational batch discipline for AI execution**.

This appendix exists so that:

- You don’t have to remember the rules    
- The AI cannot pretend it followed them    
- Future contributors inherit rigor, not folklore  
  
This *is* AI Job Control Language.
